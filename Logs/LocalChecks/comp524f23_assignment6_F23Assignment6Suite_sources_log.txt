
//SESSION START
0,Sun Dec 03 14:26:21 EST 2023,17740
//START OF FILE: index/QuoteEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.SExpression;

public class QuoteEvaluator implements Evaluator{

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		return expr.getTail();
	}

}

//END OF FILE
//START OF FILE: index/OrEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.NilAtom;
import main.lisp.parser.terms.SExpression;

public class OrEvaluator implements Evaluator {

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		expr = expr.getTail();
		return evalHelper(expr, environment);
	}

	public static SExpression evalHelper(SExpression expr, Environment environment) {
		if(expr.isAtom()) {
			if(expr.isNIL()) {
				return new NilAtom();
			}else {
				return expr;
			}
		}
		if(expr.getHead().isNIL()) {
			return evalHelper(expr.getTail(), environment);
		}else {
			return expr.getHead();
		}		
	}

}

//END OF FILE
//START OF FILE: index/LesserEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.DecimalAtom;
import main.lisp.parser.terms.IntegerAtom;
import main.lisp.parser.terms.NilAtom;
import main.lisp.parser.terms.SExpression;
import main.lisp.parser.terms.TAtom;
import main.lisp.parser.terms.TAtomicExpressionFactory;
import main.lisp.parser.terms.NilAtomicExpressionFactory;


public class LesserEvaluator extends ArithmeticEvaluatorHelper implements Evaluator{

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		return super.getDifference(expr, environment, "lesser");
	}

}

//END OF FILE
//START OF FILE: index/LesserEqualEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.DecimalAtom;
import main.lisp.parser.terms.IntegerAtom;
import main.lisp.parser.terms.NilAtom;
import main.lisp.parser.terms.SExpression;
import main.lisp.parser.terms.TAtom;
import main.lisp.parser.terms.TAtomicExpressionFactory;
import main.lisp.parser.terms.NilAtomicExpressionFactory;

public class LesserEqualEvaluator extends ArithmeticEvaluatorHelper implements Evaluator {

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		return super.getDifference(expr, environment, "LesserEqual");
	}
}

//END OF FILE
//START OF FILE: index/ArithmeticEvaluatorHelper.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.parser.terms.DecimalAtom;
import main.lisp.parser.terms.IntegerAtom;
import main.lisp.parser.terms.NilAtom;
import main.lisp.parser.terms.NilAtomicExpressionFactory;
import main.lisp.parser.terms.SExpression;
import main.lisp.parser.terms.TAtom;
import main.lisp.parser.terms.TAtomicExpressionFactory;

public class ArithmeticEvaluatorHelper {
	
	public static SExpression getDifference(SExpression expr, Environment environment, String comparator) {
		expr = expr.getTail();
		
		SExpression firstEvaled = expr.getHead().eval(environment);
		SExpression secondEvaled = expr.getTail().getHead().eval(environment);
		
		IntegerAtom firstInt = null;
		IntegerAtom secondInt = null;
		DecimalAtom firstDec = null;
		DecimalAtom secondDec = null;
		
		if (firstEvaled instanceof IntegerAtom) {
			firstInt = (IntegerAtom)firstEvaled;
			secondInt = (IntegerAtom)secondEvaled;
		}
		if (firstEvaled instanceof DecimalAtom) {
			firstDec = (DecimalAtom)firstEvaled;
			secondDec = (DecimalAtom)secondEvaled;
		}
		double difference = firstInt.getValue() - secondInt.getValue();
		if(comparator.equals("greater")) {
			if(difference > 0) {
				return TAtomicExpressionFactory.newInstance();
			}else {
				return NilAtomicExpressionFactory.newInstance();
			}
		}else if(comparator.equals("lesser")) {
			if(difference < 0) {
				return TAtomicExpressionFactory.newInstance();
			}else {
				return NilAtomicExpressionFactory.newInstance();
			}
		}else if(comparator.equals("GreaterEqual")){
			if(difference >= 0) {
				return TAtomicExpressionFactory.newInstance();
			}else {
				return NilAtomicExpressionFactory.newInstance();
			}
		}else {
			if(difference <= 0) {
				return TAtomicExpressionFactory.newInstance();
			}else {
				return NilAtomicExpressionFactory.newInstance();
			}
		}
	}
}

//END OF FILE
//START OF FILE: index/GreaterEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.DecimalAtom;
import main.lisp.parser.terms.IntegerAtom;
import main.lisp.parser.terms.NilAtom;
import main.lisp.parser.terms.SExpression;
import main.lisp.parser.terms.TAtom;

public class GreaterEvaluator extends ArithmeticEvaluatorHelper implements Evaluator{

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		return super.getDifference(expr, environment, "greater");
	}

}

//END OF FILE
//START OF FILE: index/ListEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.SExpression;
import main.lisp.parser.terms.ExpressionFactory;

public class ListEvaluator implements Evaluator{

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		expr = expr.getTail();
		return evalHelper(expr, environment);
	}
	
	public static SExpression evalHelper(SExpression expr, Environment environment) {
		if(expr.isAtom()) {
			return expr.eval(environment);
		}
		return ExpressionFactory.newInstance(expr.getHead().eval(environment), evalHelper(expr.getTail(), environment));
		
	}

}

//END OF FILE
//START OF FILE: index/EvalEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.ExpressionFactory;
import main.lisp.parser.terms.SExpression;
import main.lisp.evaluator.BuiltinOperationManagerSingleton;

public class EvalEvaluator implements Evaluator{

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		expr = expr.getTail().getHead();
		return evalHelper(expr, environment);
		
	}
	
	public static SExpression evalHelper(SExpression expr, Environment environment) {
		if(expr.isAtom()) {
			return expr;
		}
		if(!expr.getTail().getHead().isAtom()) {
			SExpression expression = ExpressionFactory.newInstance(expr.getHead(), evalHelper(expr.getTail().getHead(), environment));
			return BuiltinOperationManagerSingleton.get().getEvaluator(expr.getHead().toString()).eval(expression, environment);
		}else {
			return BuiltinOperationManagerSingleton.get().getEvaluator(expr.getHead().toString()).eval(expr, environment);
		}
		
	}
	
}

//END OF FILE
//START OF FILE: index/GreaterEqualEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.DecimalAtom;
import main.lisp.parser.terms.IntegerAtom;
import main.lisp.parser.terms.NilAtom;
import main.lisp.parser.terms.SExpression;
import main.lisp.parser.terms.TAtom;

public class GreaterEqualEvaluator extends ArithmeticEvaluatorHelper implements Evaluator {

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		return super.getDifference(expr, environment, "GreaterEqual");
	}

}

//END OF FILE
//START OF FILE: index/OperationRegistererImpl.java
package index;

import main.lisp.evaluator.OperationRegisterer;
import main.lisp.evaluator.BasicOperationRegisterer;
import main.lisp.evaluator.BuiltinOperationManagerSingleton;

public class OperationRegistererImpl extends BasicOperationRegisterer implements OperationRegisterer{
	
	public static void registerBasic() {
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("QUOTE", new QuoteEvaluator());
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("LIST", new ListEvaluator());
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("LOAD", new LoadEvaluator());
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("EVAL", new EvalEvaluator());
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("COND", new CondEvaluator());
	}
	
	public static void registerArithmetic() {
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew(">", new GreaterEvaluator());
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("<", new LesserEvaluator());
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew(">=", new GreaterEqualEvaluator());
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("<=", new LesserEqualEvaluator());
	}
	
	public static void registerLogic() {
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("AND", new AndEvaluator());
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("OR", new OrEvaluator());
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("NOT", new NotEvaluator());
	}
	
	

	@Override
	public void registerOperations() {
		registerAll();
	}
	
	public static void registerAll() {
		registerBasic();
		registerArithmetic();
		registerLogic();
	}

}

//END OF FILE
//START OF FILE: index/LoadEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.NilAtom;
import main.lisp.parser.terms.TAtom;
import main.lisp.parser.terms.SExpression;
import main.lisp.parser.terms.StringAtom;
import main.lisp.interpreter.InterpreterModel;
import main.lisp.interpreter.InterpreterModelSingleton;
import main.lisp.parser.terms.TAtomicExpressionFactory;
import main.lisp.parser.terms.NilAtomicExpressionFactory;


import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

public class LoadEvaluator implements Evaluator {

    @Override
    public SExpression eval(SExpression expr, Environment environment) {
        // Ensure the argument is a string
        if(expr.getTail().getHead() instanceof NilAtom) {
        	return NilAtomicExpressionFactory.newInstance();
        }

        String fileName = ((StringAtom)(expr.getTail().getHead())).getValue();
//        fileName = fileName.substring(fileName.lastIndexOf("/") + 1, fileName.length() - 1);
//        System.out.println("Filename: " + fileName);
        try {
//        	Charset charset = Charset.forName("ISO-8859-1");
        	List<String> lines = Files.readAllLines(Path.of(fileName));


            // Get the singleton instance of the interpreter model
            InterpreterModel interpreterModel = InterpreterModelSingleton.get();

            for (String line : lines) {
                interpreterModel.newInput(line);
            }

            return TAtomicExpressionFactory.newInstance();
        } catch (IOException e) {
        	System.out.println(e);
            return NilAtomicExpressionFactory.newInstance();
        }
    }
}

//END OF FILE
//START OF FILE: index/index.java
package index;

import main.Main;
import main.lisp.parser.terms.ExpressionFactory;

public class index {

	public static void main(String[] args) {
		OperationRegistererImpl.registerAll();
		ExpressionFactory.setClass(BasicExpressionImpl.class);
		Main.main(args);
	}

}

//END OF FILE
//START OF FILE: index/NotEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.NilAtom;
import main.lisp.parser.terms.SExpression;
import main.lisp.parser.terms.TAtom;
import main.lisp.parser.terms.TAtomicExpressionFactory;
import main.lisp.parser.terms.NilAtomicExpressionFactory;

public class NotEvaluator implements Evaluator {

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		expr = expr.getTail().getHead();
		if(expr.isNIL()) {
			return TAtomicExpressionFactory.newInstance();
		}else {
			return NilAtomicExpressionFactory.newInstance();
		}
	}

}

//END OF FILE
//START OF FILE: index/CondEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.NilAtom;
import main.lisp.parser.terms.SExpression;

public class CondEvaluator implements Evaluator{

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		expr = expr.getTail();
		return evalHelper(expr, environment);
	}
	
	public static SExpression evalHelper(SExpression expr, Environment environment) {
		if(expr.isNIL()) {
			return new NilAtom();
		}
		if(!expr.getHead().getHead().eval(environment).isNIL()) {
			if(expr.getHead().getTail().isAtom()) {
				return expr.getHead().getTail();
			}else {
				return expr.getHead().getTail().getHead();
			}
		}else {
			return evalHelper(expr.getTail(), environment);
		}
	}
}

//END OF FILE
//START OF FILE: index/RunF23A5Tests.java
package index;

import grader.basics.execution.BasicProjectExecution;
import gradingTools.comp524f23.assignment6.F23Assignment6Suite;
import trace.grader.basics.GraderBasicsTraceUtility;

public class RunF23A5Tests {
	public static void main(final String[] args) {
		
		final int maxPrintedTraces = 600;
		final int maxTraces = 2000;
		final int processTimeOut = 5;
		
		// if you set this to false, grader steps will not be traced
		GraderBasicsTraceUtility.setTracerShowInfo(true);	
		// if you set this to false, all grader steps will be traced,
		// not just the ones that failed		
		GraderBasicsTraceUtility.setBufferTracedMessages(true);
		// Change this number if a test trace gets longer than 600 and is clipped
		GraderBasicsTraceUtility.setMaxPrintedTraces(maxPrintedTraces);
		// Change this number if all traces together are longer than 2000
		GraderBasicsTraceUtility.setMaxTraces(maxTraces);
		// Change this number if your process times out prematurely
		BasicProjectExecution.setProcessTimeOut(processTimeOut);
		// You need to always call such a method
		F23Assignment6Suite.main(args);
	}
}

//END OF FILE
//START OF FILE: index/AndEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.NilAtom;
import main.lisp.parser.terms.SExpression;

public class AndEvaluator implements Evaluator {

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		expr = expr.getTail();
		return evalHelper(expr, environment);
	}

	public static SExpression evalHelper(SExpression expr, Environment environment) {
		if(expr.isAtom()) {
			if(expr.isNIL()) {
				return new NilAtom();
			}else {
				return expr;
			}
		}
		if(expr.getHead().isNIL()) {
			return new NilAtom();
		}else {
			return evalHelper(expr.getTail().getHead(), environment);
		}
	}
	
}

//END OF FILE
//START OF FILE: index/ClassRegistryImpl.java
package index;

import main.ClassRegistry;
import main.lisp.evaluator.Evaluator;
import main.lisp.evaluator.OperationRegisterer;
import main.lisp.parser.terms.SExpression;

public class ClassRegistryImpl implements ClassRegistry {

	@Override
	public Class<? extends Evaluator> getAndEvaluator() {
		// TODO Auto-generated method stub
		return AndEvaluator.class;
	}

	@Override
	public Class<? extends Evaluator> getCondEvaluator() {
		// TODO Auto-generated method stub
		return CondEvaluator.class;
	}

	@Override
	public Class<? extends OperationRegisterer> getCustomOperationRegisterer() {
		// TODO Auto-generated method stub
		return OperationRegistererImpl.class;
	}

	@Override
	public Class<? extends Evaluator> getEvalEvaluator() {
		// TODO Auto-generated method stub
		return EvalEvaluator.class;
	}

	@Override
	public Class<? extends Evaluator> getGTEEvaluator() {
		// TODO Auto-generated method stub
		return GreaterEqualEvaluator.class;
	}

	@Override
	public Class<? extends Evaluator> getGTEvaluator() {
		// TODO Auto-generated method stub
		return GreaterEvaluator.class;
	}

	@Override
	public Class<? extends Evaluator> getLTEEvaluator() {
		// TODO Auto-generated method stub
		return LesserEqualEvaluator.class;
	}

	@Override
	public Class<? extends Evaluator> getLTEvaluator() {
		// TODO Auto-generated method stub
		return LesserEvaluator.class;
	}

	@Override
	public Class<? extends Evaluator> getListEvaluator() {
		// TODO Auto-generated method stub
		return ListEvaluator.class;
	}

	@Override
	public Class<? extends Evaluator> getLoadEvaluator() {
		// TODO Auto-generated method stub
		return LoadEvaluator.class;
	}

	@Override
	public Class<?> getMain() {
		// TODO Auto-generated method stub
		return index.class;
	}

	@Override
	public Class<? extends Evaluator> getNotEvaluator() {
		// TODO Auto-generated method stub
		return NotEvaluator.class;
	}

	@Override
	public Class<? extends Evaluator> getOrEvaluator() {
		// TODO Auto-generated method stub
		return OrEvaluator.class;
	}

	@Override
	public Class<? extends Evaluator> getQuoteEvaluator() {
		// TODO Auto-generated method stub
		return QuoteEvaluator.class;
	}

	@Override
	public Class<? extends SExpression> getStringFormattingSExpression() {
		// TODO Auto-generated method stub
		return BasicExpressionImpl.class;
	}

}

//END OF FILE
//START OF FILE: index/BasicExpressionImpl.java
package index;

import main.lisp.parser.terms.AbstractSExpression;
import main.lisp.parser.terms.Atom;
import main.lisp.parser.terms.BasicExpression;
import main.lisp.parser.terms.SExpression;
import main.lisp.evaluator.BuiltinOperationManagerSingleton;

public class BasicExpressionImpl extends BasicExpression implements SExpression{
	
	public BasicExpressionImpl(SExpression head, SExpression tail) {
		super(head, tail);
	}

	@Override
	public boolean isList() {
		if((this.getTail() instanceof Atom)) {
			return this.getTail().isNIL();
		}else {
			return this.getTail().isList();
		}
	}

	@Override
	public String toStringAsSExpressionDeep() {
		if(this.isAtom()) {
			return "(" + this.toString() + ")";
		}
		return "(" + this.getHead().toStringAsSExpressionDeep() + " " + "." + " " +
				this.getTail().toStringAsSExpressionDeep() + ")";
	}

	@Override
	public String toStringAsSExpression() {
		return "(" + this.getHead().toString() + " " + "." + " " +
				this.getTail().toString() + ")";
	}

	@Override
	public String toStringAsList() {
		return "("+((AbstractSExpression)this).toStringAsListHelperPublic()+")";
	}

	@Override
	public String toString() {
		return this.isList()? this.toStringAsList() : this.toStringAsSExpression();
	}

	@Override
	public String toStringAsListHelperPublic() {
		if(this.getTail().isNIL()) {
			return this.getHead().toString();
		}else {
			return this.getHead().toString() + " " + ((AbstractSExpression)this.getTail()).toStringAsListHelperPublic();	
		}
	}

}

//END OF FILE

//SESSION END

//SESSION START
3,Sun Dec 03 14:38:02 EST 2023,-48
//START OF FILE: index/OrEvaluator.java
=124	-39	=351	-1	=1	-11	+xpr	=169
//END OF FILE

//SESSION END

//SESSION START
4,Sun Dec 03 14:38:39 EST 2023,63
//START OF FILE: index/OrEvaluator.java
=270	+// 	=25	+// 	=39	+%09return expr;%0A%09	=4	+// 	=83	+// 	=22	+// 	=22	+// 	=17	+// 	=11	+// 	=17	+// 	=5	+// 	=4	+// 	=31	+// 	=51	+// 	=10	+// 	=26	+// 	=6	+// 	=5
//END OF FILE

//SESSION END

//SESSION START
5,Sun Dec 03 14:42:06 EST 2023,-28
//START OF FILE: index/OrEvaluator.java
=270	-3	=25	-3	=39	-15	=4	-3	=83	-3	=22	-3	=22	-3	=17	-3	=11	-3	=17	-3	=5	-3	=4	-3	=19	+eval(environment).	=12	-3	=51	-3	=10	-3	=23	+.eval(environment)	=3	-3	=6	-3	=4	-1
//END OF FILE

//SESSION END

//SESSION START
6,Sun Dec 03 14:43:10 EST 2023,21
//START OF FILE: index/AndEvaluator.java
=310	+// 	=25	+// 	=36	+;%0A%09%09return expr	=334
//END OF FILE

//SESSION END

//SESSION START
7,Sun Dec 03 14:44:22 EST 2023,18
//START OF FILE: index/AndEvaluator.java
=577	+.eval(environment)	=149
//END OF FILE

//SESSION END

//SESSION START
8,Sun Dec 03 14:44:45 EST 2023,-21
//START OF FILE: index/AndEvaluator.java
=310	-3	=25	-3	=36	-15	=352
//END OF FILE

//SESSION END

//SESSION START
9,Sun Dec 03 14:59:44 EST 2023,-21
//START OF FILE: index/AndEvaluator.java
=124	-39	=307	+eval(environment).	=45	-1	=1	-11	+xpr	=28	-18	=31	+eval(environment).	=21	+expr.getHead().eval(e	=1	-4	+v	=1	-3	+r	=1	+n	=1	-1	+ent	=46	-10	=29
//END OF FILE

//SESSION END

//SESSION START
10,Sun Dec 03 15:00:31 EST 2023,0
//START OF FILE: index/AndEvaluator.java
=431	-18	=225	+).eval(environment	=28
//END OF FILE

//SESSION END

//SESSION START
11,Sun Dec 03 15:11:04 EST 2023,3
//START OF FILE: index/AndEvaluator.java
=294	+//	=38	+;%0A%09%09return expr	=293	+%0A%09%09%09	=31	-18	=28
//END OF FILE

//SESSION END

//SESSION START
12,Sun Dec 03 15:11:54 EST 2023,18
//START OF FILE: index/AndEvaluator.java
=349	+.eval(environment)	=356
//END OF FILE

//SESSION END

//SESSION START
13,Sun Dec 03 15:12:42 EST 2023,44
//START OF FILE: index/AndEvaluator.java
=338	+System.out.print(expr.eval(environment));%0A%09%09	=385
//END OF FILE

//SESSION END

//SESSION START
14,Sun Dec 03 15:18:23 EST 2023,-33
//START OF FILE: index/AndEvaluator.java
=294	-2	=26	-77	=305	+System.out.println(expr.getTail().toString());	=63
//END OF FILE

//SESSION END

//SESSION START
15,Sun Dec 03 15:20:18 EST 2023,2
//START OF FILE: index/AndEvaluator.java
=622	+//	=112
//END OF FILE

//SESSION END

//SESSION START
16,Sun Dec 03 15:21:55 EST 2023,-18
//START OF FILE: index/AndEvaluator.java
=539	-18	=179
//END OF FILE

//SESSION END

//SESSION START
17,Sun Dec 03 15:22:08 EST 2023,28
//START OF FILE: index/AndEvaluator.java
=539	+eval(environment).	=150	+().getHead	=29
//END OF FILE

//SESSION END

//SESSION START
18,Sun Dec 03 16:12:35 EST 2023,534
//START OF FILE: index/AndEvaluator.java
=137	+import main.lisp.parser.terms.NilAtom;%0A	=51	-1	+    	=10	-1	+    	=69	-2	+        // Start with the first argument of the AND expression.%0A        	=23	-2	+        	=35	+, null	=3	-1	+    	=3	-1	+    	=78	+, SExpression lastEvaluated	=4	-2	+        // Check 	=2	-1	+ the 	=4	-1	+ession 	=2	-3	+ e	=1	+pty 	=1	-2	+reached	=1	-1	+the end of the list).	=1	-3	+        	=2	+ 	=5	-1	+ 	=1	+n	=1	+tanceof 	=1	-4	+ilAtom	=4	-4	+            // If all expressions were non-nil, 	=7	+the last evaluated 	=4	-1	+ession.	=1	-4	+            r	=1	+turn 	=1	+a	=1	+tEvaluat	=1	+d;%0A   	=1	-1	+    %7D	=1	-5	+%0A        // Evaluat	=1	+ 	=1	+he c	=2	+re	=1	+t	=1	+h	=1	+ad and store it.%0A        SE	=3	-13	+ess	=1	-2	+on current = 	=32	+;%0A%0A        // Check if the evaluated head is NIL.%0A        if (current	=12	-3	+            	=7	-3	+cu	=1	-2	+r	=1	+n	=1	-1	+; // R	=1	-5	+turn th	=1	-4	+ first NIL 	=2	-3	+c	=1	-3	+u	=2	-2	+ered.	=1	-2	+        	=1	+ 	=7	+            	=2	-10	+ C	=1	-1	+n	=1	-3	=2	+ue wi	=1	-3	+h th	=1	-2	+ 	=1	-2	=1	+s	=1	-1	+ of the list, upd	=1	+t	=1	+ng the 	=1	-3	+as	=1	-2	+ evalua	=1	+ed exp	=1	+ess	=1	+o	=1	-5	+.	=1	-3	+            	=32	-10	=13	+, current	=3	-2	+        	=2	-1	+    	=1	-2	=3
//END OF FILE

//SESSION END

//SESSION START
19,Sun Dec 03 19:47:54 EST 2023,-453
//START OF FILE: index/AndEvaluator.java
=322	-64	=203	-75	=43	-86	=32	-52	=64	-48	=58	-37	=17	-91	=88
//END OF FILE

//SESSION END

//SESSION START
20,Sun Dec 03 19:59:36 EST 2023,-33
//START OF FILE: index/BasicExpressionImpl.java
=193	-61	=212	+%0A%09%09System.out.println(this);	=1043
//END OF FILE

//SESSION END

//SESSION START
21,Sun Dec 03 20:04:48 EST 2023,-28
//START OF FILE: index/BasicExpressionImpl.java
=408	-28	=1040
//END OF FILE

//SESSION END

//SESSION START
22,Mon Dec 04 12:46:57 EST 2023,3467
//START OF FILE: index/EnvironmentImpl.java
package index;

import java.util.Optional;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.environment.AbstractEnvironment;
import main.lisp.evaluator.function.Function;
import main.lisp.parser.terms.IdentifierAtom;
import main.lisp.parser.terms.SExpression;

public class EnvironmentImpl extends AbstractEnvironment{

	public EnvironmentImpl(Environment parent) {
		super(parent);
	}

	@Override
	public void assign(IdentifierAtom arg0, SExpression arg1) {
		put(arg0, arg1);
	}

	@Override
	public void assignFun(IdentifierAtom arg0, Function arg1) {
		
	}

	@Override
	public Environment copy() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Optional<SExpression> lookup(IdentifierAtom arg0) {
		Optional<SExpression> retVal = get(arg0);
		return (retVal == null && getParent() != null) ? getParent().lookup(arg0) : retVal;
	}

	@Override
	public Optional<Function> lookupFun(IdentifierAtom arg0) {
		// TODO Auto-generated method stub
		return Optional.empty();
	}

	@Override
	public Environment newChild() {
		return new EnvironmentImpl(this);
	}
	
}

//END OF FILE
//START OF FILE: index/CondEvaluator.java
=601	+ instanceof NilAtom) %7B%0A%09%09%09%09return expr.getHead().getHead().eval(environment);%0A%09%09%09%7D%0A%09%09%09if(expr.getHead().getTail()	=105	+).eval(environment	=78
//END OF FILE
//START OF FILE: index/ClassRegistryImpl.java
=28	-1	=1	-2	+i	=1	-1	+p.	=1	-1	+valuator.Env	=1	-2	=1	-1	+onment	=39	+%09	=79	+IdentifierAtom;%0Aimport main.lisp.parser.terms.	=13	+import gradingTools.comp524f23.assignment6.ClassRegistryA6;%0A	=56	+A6	=2095	+;%0A%09%7D%0A%0A%09@Override%0A%09public Class%3C? extends SExpression%3E getFunctionCallingSExpression() %7B%0A%09%09// TODO Auto-generated method stub%0A%09%09throw new UnsupportedOperationException(%22Unimplemented method 'getFunctionCallingSExpression'%22);%0A%09%7D%0A%0A%09@Override%0A%09public Class%3C? extends Evaluator%3E getFunctionEvaluator() %7B%0A%09%09// TODO Auto-generated method stub%0A%09%09throw new UnsupportedOperationException(%22Unimplemented method 'getFunctionEvaluator'%22);%0A%09%7D%0A%0A%09@Override%0A%09public Class%3C? extends Evaluator%3E getLetEvaluator() %7B%0A%09%09// TODO Auto-generated method stub%0A%09%09throw new UnsupportedOperationException(%22Unimplemented method 'getLetEvaluator'%22);%0A%09%7D%0A%0A%09@Override%0A%09public Class%3C? extends Evaluator%3E getBasicFuncallEvaluator() %7B%0A%09%09// TODO Auto-generated method stub%0A%09%09throw new UnsupportedOperationException(%22Unimplemented method 'getBasicFuncallEvaluator'%22);%0A%09%7D%0A%0A%09@Override%0A%09public Class%3C? extends IdentifierAtom%3E getIdentifierAtomWithLookup() %7B%0A%09%09// TODO Auto-generated method stub%0A%09%09throw new UnsupportedOperationException(%22Unimplemented method 'getIdentifierAtomWithLookup'%22);%0A%09%7D%0A%0A%09@Override%0A%09public Class%3C? extends SExpression%3E getLambdaCallingSExpression() %7B%0A%09%09// TODO Auto-generated method stub%0A%09%09throw new UnsupportedOperationException(%22Unimplemented method 'getLambdaCallingSExpression'%22);%0A%09%7D%0A%0A%09@Override%0A%09public Class%3C? extends Evaluator%3E getLambdaEvaluator() %7B%0A%09%09// TODO Auto-generated method stub%0A%09%09throw new UnsupportedOperationException(%22Unimplemented method 'getLambdaEvaluator'%22);%0A%09%7D%0A%0A%09@Override%0A%09public Class%3C? extends Environment%3E getNestedLexicalEnvironment() %7B%0A%09%09// TODO Auto-generated method stub%0A%09%09throw new UnsupportedOperationException(%22Unimplemented method 'getNestedLexicalEnvironment'%22);%0A%09%7D%0A%0A%09@Override%0A%09public Class%3C? extends Evaluator%3E getSetqEvaluator() %7B%0A%09%09// TODO Auto-generated method stub%0A%09%09throw new UnsupportedOperationException(%22Unimplemented method 'getSetqEvaluator'%22);%0A%09%7D%0A%0A%09@Override%0A%09public Class%3C? extends OperationRegisterer%3E getStatefulOperationRegisterer() %7B%0A%09%09// TODO Auto-generated method stub%0A%09%09throw new UnsupportedOperationException(%22Unimplemented method 'getStatefulOperationRegisterer'%22)	=8
//END OF FILE

//SESSION END

//SESSION START
24,Mon Dec 04 12:52:06 EST 2023,-65
//START OF FILE: index/ClassRegistryImpl.java
=4033	-2	=1	-4	=1	-10	=1	-5	+u	=1	-4	=1	-24	=1	-24	=11	-3	+Impl.class	=434
//END OF FILE

//SESSION END

//SESSION START
25,Mon Dec 04 13:23:33 EST 2023,729
//START OF FILE: index/EnvironmentImpl.java
=363	+) %7B%0A%09%09super();%0A%09%7D%0A%0A%09public EnvironmentImpl(	=744
//END OF FILE
//START OF FILE: index/SetqEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.IdentifierAtom;
import main.lisp.parser.terms.SExpression;

public class SetqEvaluator implements Evaluator{

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		expr = expr.getTail();
		return evalHelper(expr, environment);
	}
	
	public static SExpression evalHelper(SExpression expr, Environment environment) {
        SExpression e2 = expr.getTail().getHead();
        SExpression e2Eval = e2.eval(environment);
        environment.assign((IdentifierAtom)expr.getHead(), e2Eval);
        return e2Eval;
	}
}

//END OF FILE
//START OF FILE: index/index.java
=83	+import main.lisp.evaluator.environment.EnvironmentFactory;%0A	=64	+%0A%09%09EnvironmentFactory.setClass(EnvironmentImpl.class);	=124
//END OF FILE
//START OF FILE: index/ClassRegistryImpl.java
=4136	-17	=1	-6	=2	-6	=1	-6	=1	-3	=1	-2	=1	-56	=13	-3	+.class	=240
//END OF FILE

//SESSION END

//SESSION START
26,Mon Dec 04 13:26:00 EST 2023,137
//START OF FILE: index/OperationRegistererImpl.java
=1550	+public static void registerAdvance() %7B%0A%09%09BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew(%22SETQ%22, new SetqEvaluator());%0A%09%7D%0A%09	=175
//END OF FILE

//SESSION END

//SESSION START
27,Mon Dec 04 13:26:21 EST 2023,21
//START OF FILE: index/OperationRegistererImpl.java
=1857	+%09registerAdvance();%0A%09	=5
//END OF FILE

//SESSION END

//SESSION START
29,Mon Dec 04 13:27:17 EST 2023,24
//START OF FILE: index/SetqEvaluator.java
=342	+// 	=36	+;%0A        return expr	=288
//END OF FILE

//SESSION END

//SESSION START
30,Mon Dec 04 13:42:37 EST 2023,219
//START OF FILE: index/EvalEvaluator.java
=173	+IdentifierAtom;%0Aimport main.lisp.parser.terms.	=12	+%0Aimport java.util.Optional;%0A	=385	+Optional%3CSExpression%3E retVal = environment.lookup((IdentifierAtom)expr);%0A%09%09%09if(retVal.isPresent()) %7B%0A%09%09%09%09return retVal.get();%0A%09%09%09%7Delse%7B%0A%09%09%09%09	=12	+%0A%09%09%09%7D	=432
//END OF FILE

//SESSION END

//SESSION START
31,Mon Dec 04 13:43:05 EST 2023,-24
//START OF FILE: index/SetqEvaluator.java
=342	-3	=36	-21	=288
//END OF FILE

//SESSION END

//SESSION START
32,Mon Dec 04 15:03:55 EST 2023,601
//START OF FILE: index/ArithmeticEvaluatorHelper.java
=179	-39	=62	-37	=1551
//END OF FILE
//START OF FILE: index/index.java
=100	+parser.terms.IdentifierAtomFactory;%0Aimport main.lisp.	=106	+%0A%09%09IdentifierAtomFactory.setClass(IdentifierAtomImpl.class);	=178
//END OF FILE
//START OF FILE: index/EvalEvaluator.java
=232	+%0A	=297	-1	=180	+ 	=64	-5	=1	-1	=15	-5	=432
//END OF FILE
//START OF FILE: index/IdentifierAtomImpl.java
package index;

import java.util.Optional;

import main.lisp.scanner.tokens.Token;
import main.lisp.evaluator.Environment;
import main.lisp.parser.terms.IdentifierAtom;
import main.lisp.parser.terms.SExpression;

public class IdentifierAtomImpl extends IdentifierAtom implements SExpression{

    public IdentifierAtomImpl(String string) {
        super(string);
    }
    
    public IdentifierAtomImpl(Token token) {
        super(token);
     }

    @Override
    public SExpression eval(Environment var1){
        Optional<SExpression> retVal = var1.lookup(this);
        if(retVal.isPresent()) {
            return retVal.get();
        }
        return this;
    }
}

//END OF FILE
//START OF FILE: index/ClassRegistryImpl.java
=3362	-17	=1	-6	=2	-6	=1	-6	=1	-3	=1	-2	=1	-56	=14	-9	+Im	=1	-3	+l.class	=910
//END OF FILE

//SESSION END

//SESSION START
33,Mon Dec 04 15:06:02 EST 2023,-209
//START OF FILE: index/EvalEvaluator.java
=173	-46	=13	-29	=268	+%09	=2	-0	=88	+	=21	-135	=448
//END OF FILE

//SESSION END

//SESSION START
34,Mon Dec 04 15:09:14 EST 2023,10
//START OF FILE: index/QuoteEvaluator.java
=293	+.getHead()	=8
//END OF FILE

//SESSION END

//SESSION START
35,Mon Dec 04 15:10:09 EST 2023,19
//START OF FILE: index/EvalEvaluator.java
=381	+return expr;%0A//%09%09	=33	+//	=600
//END OF FILE

//SESSION END

//SESSION START
36,Mon Dec 04 15:59:51 EST 2023,191
//START OF FILE: index/QuoteEvaluator.java
=272	+if(expr.getTail().isAtom()) %7B%0A%09%09%09return expr.getTail();%0A%09%09%7D%0A%09%09	=35	-1	=3
//END OF FILE
//START OF FILE: index/EvalEvaluator.java
=381	-17	=33	-2	=40	-3	=132	+%0A%09%09boolean 	=1	-1	+sOperator = 	=35	+) && (BuiltinOperationManagerSingleton.get().getEvaluator(expr.getTail().getHead().getHead().toString()) != null);%0A%09%09if(isOperator	=388
//END OF FILE

//SESSION END

//SESSION START
37,Mon Dec 04 16:00:26 EST 2023,17
//START OF FILE: index/EvalEvaluator.java
=414	+//	=38	+;%0A%09%09return expr	=711
//END OF FILE

//SESSION END

//SESSION START
38,Mon Dec 04 16:01:22 EST 2023,2
//START OF FILE: index/EvalEvaluator.java
=379	+//	=801
//END OF FILE

//SESSION END

//SESSION START
39,Mon Dec 04 16:03:31 EST 2023,71
//START OF FILE: index/EvalEvaluator.java
=379	-2	+%09%09if(expr.getTail().isAtom()) %7B%0A%09%09%09expr = expr.getTail();%0A%09%09%7Delse %7B%0A%09	=35	-2	+%09%09%7D%0A	=40	+//	=724
//END OF FILE

//SESSION END

//SESSION START
40,Mon Dec 04 16:04:11 EST 2023,19
//START OF FILE: index/CondEvaluator.java
=308	+//	=25	+//	=38	+;%0A%09%09return expr	=544
//END OF FILE

//SESSION END

//SESSION START
41,Mon Dec 04 16:06:43 EST 2023,-2
//START OF FILE: index/CondEvaluator.java
=308	-2	=25	-2	=40	+//	=557
//END OF FILE

//SESSION END

//SESSION START
42,Mon Dec 04 16:07:15 EST 2023,10
//START OF FILE: index/EvalEvaluator.java
=379	+//	=32	+//	=26	+//	=10	+//	=36	+//	=4	+//	=40	-2	=724
//END OF FILE

//SESSION END

//SESSION START
43,Mon Dec 04 16:08:03 EST 2023,2
//START OF FILE: index/CondEvaluator.java
=308	+//	=25	+//	=40	-2	=557
//END OF FILE

//SESSION END

//SESSION START
44,Mon Dec 04 16:11:55 EST 2023,-2
//START OF FILE: index/CondEvaluator.java
=308	-2	=25	-2	=40	+//	=557
//END OF FILE

//SESSION END

//SESSION START
45,Mon Dec 04 16:13:10 EST 2023,9
//START OF FILE: index/ListEvaluator.java
=318	+//	=25	+//	=38	+;%0A%09%09return expr	=274
//END OF FILE
//START OF FILE: index/EvalEvaluator.java
=379	-2	=32	-2	=26	-2	=10	-2	=36	-2	=4	-2	=40	+//	=724
//END OF FILE

//SESSION END

//SESSION START
46,Mon Dec 04 16:14:54 EST 2023,-20
//START OF FILE: index/ListEvaluator.java
=318	-2	=25	-2	=40	+//	=215	-18	=54
//END OF FILE

//SESSION END

//SESSION START
47,Mon Dec 04 16:19:26 EST 2023,18
//START OF FILE: index/ListEvaluator.java
=601	+.eval(environment)	=53
//END OF FILE

//SESSION END

//SESSION START
49,Mon Dec 04 16:56:17 EST 2023,1203
//START OF FILE: index/LambdaEvaluator.java
package index;

import java.util.ArrayList;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.IdentifierAtom;
import main.lisp.parser.terms.NilAtom;
import main.lisp.evaluator.function.LambdaFactory;
import main.lisp.parser.terms.SExpression;

public class LambdaEvaluator implements Evaluator{

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
        expr = expr.getTail();
		return evalHelper(expr, environment);
	}
	
	public static SExpression evalHelper(SExpression expr, Environment environment) {
        IdentifierAtom ids[] = extractIdentifiers(expr.getHead());
        return LambdaFactory.newInstance(ids, expr.getHead().getTail());
	}

    private static IdentifierAtom[] extractIdentifiers(SExpression expr) {
        ArrayList<IdentifierAtom> ids = new ArrayList<>();
        while(expr instanceof NilAtom) {
            ids.add((IdentifierAtom) expr.getHead());
            expr = expr.getTail();
        }
        IdentifierAtom[] idArray = new IdentifierAtom[ids.size()];
        for(IdentifierAtom id : ids) {
            idArray[ids.indexOf(id)] = id;
        }
        return idArray;
    }
}
//END OF FILE

//SESSION END

//SESSION START
50,Mon Dec 04 17:16:35 EST 2023,42
//START OF FILE: index/OperationRegistererImpl.java
=1684	+%09BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew(%22LAMBDA%22, new LambdaEvaluator());%0A%09	=199
//END OF FILE
//START OF FILE: index/ClassRegistryImpl.java
=3725	-2	=1	-4	=1	-5	+t	=1	-3	=1	-20	=1	-15	=1	-11	=15	-3	+.class	=494
//END OF FILE

//SESSION END

//SESSION START
51,Mon Dec 04 17:26:37 EST 2023,-7
//START OF FILE: index/LambdaEvaluator.java
=716	-10	=161	+!(	=23	+)	=293
//END OF FILE

//SESSION END

//SESSION START
52,Mon Dec 04 20:23:43 EST 2023,772
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
package index;

import main.lisp.evaluator.BasicExpressionEvaluator;
import main.lisp.evaluator.BuiltinOperationManagerSingleton;
import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.evaluator.function.Lambda;
import main.lisp.parser.terms.IdentifierAtom;
import main.lisp.parser.terms.SExpression;

public class BasicExpressionEvaluatorImpl extends BasicExpressionEvaluator{
	
	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		Environment childEnvironment = environment.newChild();
		LambdaEvaluator lambdaEvaluator = new LambdaEvaluator();
		Lambda lambda = (Lambda)lambdaEvaluator.eval(expr, environment);
		IdentifierAtom[] ids = lambda.getArgumentNames();
		childEnvironment.assign(null, lambda);
		return expr;
	}

}

//END OF FILE
//START OF FILE: index/index.java
=163	+ExpressionEvaluatorFactory;%0Aimport main.lisp.evaluator.	=96	+%0A%09%09ExpressionEvaluatorFactory.setClass(BasicExpressionEvaluatorImpl.class);	=238
//END OF FILE
//START OF FILE: index/ClassRegistryImpl.java
=3481	-17	=1	-2	=1	-10	=2	-6	=1	-3	=1	-2	=1	-1	=1	-1	=1	-32	=1	-27	=1	-18	=74	-37	=525
//END OF FILE

//SESSION END

//SESSION START
53,Mon Dec 04 20:24:31 EST 2023,19
//START OF FILE: index/LambdaEvaluator.java
=436	+//	=31	+//	=38	+;%0A%09%09return expr	=691
//END OF FILE

//SESSION END

//SESSION START
54,Mon Dec 04 22:50:33 EST 2023,379
//START OF FILE: index/LambdaEvaluator.java
=436	-2	=31	-2	=42	+// 	=702
//END OF FILE
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
=244	+BasicLambda;%0Aimport main.lisp.evaluator.function.	=8	-0	=166	-1	=1	+	=81	+%09%09if(BuiltinOperationManagerSingleton.get().getEvaluator(expr.getHead().getHead().toString()).getClass().equals(LambdaEvaluator.class))%7B%0A%09	=59	+%09	=59	+%09	=49	+.getHead()	=16	+%09	=54	+%09for (IdentifierAtom id : ids)%7B%0A%09%09%09%09	=24	+id, expr.getTail().getHead().eval(e	=1	-1	+vironment));%0A%09%09%09%09expr = expr.getTai	=1	-2	+();%0A%09%09%09%7D%0A%09%09%09return	=7	+.eval(childEnvironment	=5	+%7Delse%7B%0A%09%09%09	=7	+super.eval(	=4	+, environment)	=2	+%09	=3	+%09%7D	=3
//END OF FILE

//SESSION END

//SESSION START
55,Mon Dec 04 22:53:12 EST 2023,-10
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
=621	-10	=547
//END OF FILE

//SESSION END

//SESSION START
56,Mon Dec 04 23:01:53 EST 2023,31
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
=551	-3	+// 	=118	+);%0A%09%09if(!expr.getHead().isAtom(	=496
//END OF FILE

//SESSION END

//SESSION START
58,Mon Dec 04 23:11:30 EST 2023,172
//START OF FILE: index/EvalEvaluator.java
=173	+IdentifierAtom;%0Aimport main.lisp.parser.terms.	=480	+%0A%09%09%09if(environment.lookup((IdentifierAtom)expr).isPresent()) %7B%0A%09%09%09%09return environment.lookup((IdentifierAtom)expr).get();%0A%09%09%09%7D	=600
//END OF FILE

//SESSION END

//SESSION START
59,Mon Dec 04 23:15:24 EST 2023,36
//START OF FILE: index/EvalEvaluator.java
=706	+(expr instanceof IdentifierAtom) && 	=719
//END OF FILE

//SESSION END

//SESSION START
60,Mon Dec 04 23:16:52 EST 2023,-274
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
=96	-61	=11	-87	=293	-126	=525
//END OF FILE

//SESSION END

//SESSION START
61,Tue Dec 05 15:52:12 EST 2023,932
//START OF FILE: index/FuncallEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.evaluator.function.Lambda;
import main.lisp.parser.terms.ExpressionFactory;
import main.lisp.parser.terms.NilAtom;
import main.lisp.parser.terms.SExpression;


public class FuncallEvaluator implements Evaluator{

    @Override
    public SExpression eval(SExpression expr, Environment environment) {
        expr = expr.getTail();
		return evalHelper(expr, environment);
    }
    public static SExpression evalHelper(SExpression expr, Environment environment) {
        Lambda lambda = (Lambda) expr.getHead().eval(environment);
        SExpression expression = ExpressionFactory.newInstance(lambda, expr.getTail());
        return expression.eval(environment);
//        BasicExpressionEvaluatorImpl basicExpressionEvaluatorImpl = new BasicExpressionEvaluatorImpl();
//        return basicExpressionEvaluatorImpl.eval(expression, environment);
	}
}

//END OF FILE
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
=96	+BuiltinOperationManagerSingleton;%0Aimport main.lisp.evaluator.	=311	+(	=14	-1	+ 	=1	+n	=1	+tanceof Identifier	=4	-1	=62	-60	=27	-20	=15	-13	=299
//END OF FILE
//START OF FILE: index/OperationRegistererImpl.java
=1782	+%09BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew(%22FUNCALL%22, new FuncallEvaluator());%0A%09	=199
//END OF FILE
//START OF FILE: index/ClassRegistryImpl.java
=2746	-17	=1	-6	=2	-6	=1	-6	=1	-3	=1	-2	=1	-56	=4	-4	+all	=9	-3	+.class	=1222
//END OF FILE
//START OF FILE: index/IdentifierAtomImpl.java
=267	-23	=383
//END OF FILE

//SESSION END

//SESSION START
63,Tue Dec 05 16:02:36 EST 2023,32
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
=96	-61	=423	+Evaluator lambdaEvaluator = new LambdaEvaluator();%0A%09%09%09Lambda	=18	+lambdaEvaluator.eval	=15	+, environment	=299
//END OF FILE

//SESSION END

//SESSION START
64,Tue Dec 05 16:21:54 EST 2023,-183
//START OF FILE: index/FuncallEvaluator.java
=774	-183	=5
//END OF FILE

//SESSION END

//SESSION START
66,Tue Dec 05 16:34:47 EST 2023,-32
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
=96	+BuiltinOperationManagerSingleton;%0Aimport main.lisp.evaluator.	=423	-60	=18	-20	=15	-13	=299
//END OF FILE

//SESSION END

//SESSION START
68,Tue Dec 05 16:40:01 EST 2023,32
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
=96	-61	=423	+Evaluator lambdaEvaluator = new LambdaEvaluator();%0A%09%09%09Lambda	=18	+lambdaEvaluator.eval	=15	+, environment	=299
//END OF FILE

//SESSION END

//SESSION START
69,Tue Dec 05 16:42:49 EST 2023,-32
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
=96	+BuiltinOperationManagerSingleton;%0Aimport main.lisp.evaluator.	=423	-60	=18	-20	=15	-13	=299
//END OF FILE

//SESSION END

//SESSION START
70,Tue Dec 05 16:43:49 EST 2023,10
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
=613	+.getHead()	=299
//END OF FILE

//SESSION END

//SESSION START
71,Tue Dec 05 16:45:48 EST 2023,-10
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
=613	-10	=299
//END OF FILE

//SESSION END

//SESSION START
72,Tue Dec 05 16:50:56 EST 2023,73
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
=872	-1	+BuiltinOperationManagerSingleton.get().getEval	=1	+ator(ex	=1	+r.g	=1	+tHead().toSt	=1	+ing())	=35
//END OF FILE

//SESSION END

//SESSION START
73,Tue Dec 05 16:52:07 EST 2023,18
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
=613	+.eval(environment)	=372
//END OF FILE

//SESSION END

//SESSION START
76,Tue Dec 05 17:03:44 EST 2023,118
//START OF FILE: index/LambdaEvaluator.java
=613	-8	+%09%09	=20	+ = null;%0A%09%09if(expr.getHead() instanceof NilAtom) %7B%0A%09%09%09return LambdaFactory.newInstance(ids, expr.getTail());%0A%09%09%7D%0A        ids	=573
//END OF FILE

//SESSION END

//SESSION START
77,Tue Dec 05 17:10:41 EST 2023,-20
//START OF FILE: index/LambdaEvaluator.java
=508	-18	=112	-4	+%7B%7D	=690
//END OF FILE

//SESSION END

//SESSION START
79,Tue Dec 05 17:15:08 EST 2023,-18
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
=613	-18	=372
//END OF FILE

//SESSION END

//SESSION START
80,Tue Dec 05 17:15:55 EST 2023,18
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
=613	+.eval(environment)	=372
//END OF FILE

//SESSION END

//SESSION START
81,Tue Dec 05 17:16:25 EST 2023,-18
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
=613	-18	=372
//END OF FILE

//SESSION END

//SESSION START
82,Tue Dec 05 17:24:35 EST 2023,16
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
=598	-1	=14	+.eval(environment	=372
//END OF FILE

//SESSION END

//SESSION START
84,Tue Dec 05 17:44:24 EST 2023,-133
//START OF FILE: index/FuncallEvaluator.java
=582	-67	=55	-1	+expr.getHe	=1	-2	=1	+().ev	=1	+l(environment)	=69
//END OF FILE
//START OF FILE: index/EnvironmentImpl.java
=843	-69	=238
//END OF FILE
//START OF FILE: index/LambdaEvaluator.java
=597	+SExpression body = expr.getTail();%0A%09%09	=110	-14	+body	=103	-14	+body	=474
//END OF FILE
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
=516	+SExpression temp = expr.getHead();%0A%09%09%09	=82	-7	=1	-1	=1	-4	+mp	=389
//END OF FILE
//START OF FILE: index/IdentifierAtomImpl.java
=553	-37	=19	-31	=10
//END OF FILE

//SESSION END

//SESSION START
85,Tue Dec 05 17:52:44 EST 2023,-974
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
=612	+%0A%09%09%09	=28	-18	=371
//END OF FILE
//START OF FILE: index/EvalEvaluator.java
=427	-150	=11	-326	=21	-23	=1	-33	=3	-5	=2	-187	=11	-45	=1	-1	=1	-8	=3	-5	=2	-44	=14	-1	=1	-132	=3
//END OF FILE

//SESSION END

//SESSION START
86,Tue Dec 05 18:19:26 EST 2023,296
//START OF FILE: index/FuncallEvaluator.java
=578	+%09SExpression tt = expr.getHead().eval(environment);%0A    	=160
//END OF FILE
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
=206	+BasicLambda;%0Aimport main.lisp.evaluator.function.	=406	+Lambda lambda;	=4	+if(!(temp.getClass().equals(Basic	=6	+.class)))	=1	+%7B%0A%09%09%09%09	=21	+.eval(environment)	=1	+%0A%09%09%09%7Delse %7B%0A%09%09%09%09lambda = (Lambda)temp;%0A%09%09%09%7D	=370
//END OF FILE
//START OF FILE: index/IdentifierAtomImpl.java
=553	+if(retVal.isPresent()) %7B%0A            	=19	+;%0A        %7D%0A        return this	=10
//END OF FILE

//SESSION END

//SESSION START
90,Wed Dec 06 11:18:05 EST 2023,79
//START OF FILE: index/EnvironmentImpl.java
=843	+(retVal == null && this.getParent() != null) ? this.getParent().lookup(arg0) : 	=238
//END OF FILE

//SESSION END

//SESSION START
91,Wed Dec 06 14:13:44 EST 2023,-170
//START OF FILE: index/FuncallEvaluator.java
=578	-56	=160
//END OF FILE
//START OF FILE: index/EnvironmentImpl.java
=850	-8	+.isEmpty()	=302
//END OF FILE
//START OF FILE: index/ClassRegistryImpl.java
=2753	-2	=1	-8	=1	-6	+l	=1	-3	=275	-17	=1	-6	=2	-6	=1	-6	=1	-3	=1	-2	=1	-61	=16	-3	+.class	=820
//END OF FILE

//SESSION END

//SESSION START
92,Wed Dec 06 14:30:55 EST 2023,997
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
=603	+// 	=218	+return lambdaHelper(lambda, expr, environment);%0A%09%09%09// 	=53	+// 	=34	+// 	=77	+// 	=27	+// 	=5	+// 	=164	+%0A%09%7D%0A%0A%09public static SExpression lambdaHelper(Lambda lambda, SExpression expr, Environment environment)%7B%0A%09%09Environment childEnvironment = environment.newChild();%0A%09%09IdentifierAtom%5B%5D ids = lambda.getArgumentNames();%0A%09%09for (IdentifierAtom id : ids)%7B%0A%09%09%09childEnvironment.assign(id, expr.getTail().getHead().eval(environment));%0A%09%09%09expr = expr.getTail();%0A%09%09%7D%0A%09%09return lambda.eval(childEnvironment);	=6
//END OF FILE
//START OF FILE: index/FunctionEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.evaluator.function.FunctionFactory;
import main.lisp.evaluator.function.Lambda;
import main.lisp.parser.terms.SExpression;

public class FunctionEvaluator implements Evaluator{

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
        Lambda lambda = (Lambda)expr.getHead().getTail().eval(environment);
        return FunctionFactory.newInstance(lambda, environment);
	}
}

//END OF FILE
//START OF FILE: index/ClassRegistryImpl.java
=2753	+Fu	=1	-1	+ca	=2	+Evaluator.class	=1124
//END OF FILE

//SESSION END

//SESSION START
93,Wed Dec 06 14:44:21 EST 2023,391
//START OF FILE: index/FuncallEvaluator.java
=582	+Lambda lambda = (Lambda) expr.getHead().eval(environment);%0A        return BasicExpressionEvaluatorImpl.lambdaHelper(lambda, expr, environment);%0A        // 	=113	+ //	=43
//END OF FILE
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
=255	+Function;%0Aimport main.lisp.evaluator.function.	=1387	+);%0A%09%7D%0A%0A%09public static SExpression functionHelper(Function function, SExpression expr, Environment environment)%7B%0A%09%09return lambdaHelper(function.getLambda(), expr, function.getEnvironment()	=8
//END OF FILE

//SESSION END

//SESSION START
94,Wed Dec 06 14:48:15 EST 2023,310
//START OF FILE: index/FuncallEvaluator.java
=130	+Function;%0Aimport main.lisp.evaluator.function.	=452	+SExpression body = expr.getHead().eval(environment);%0A        return body instanceof Lambda ? BasicExpressionEvaluatorImpl.lambdaHelper((Lambda)body, expr, environment) : BasicExpressionEvaluatorImpl.functionHelper((Function)body, expr, environment);%0A        // 	=66	+ //	=248
//END OF FILE

//SESSION END

//SESSION START
95,Wed Dec 06 14:49:51 EST 2023,138
//START OF FILE: index/OperationRegistererImpl.java
=71	+valgrindpp.codegen.Function;%0Aimport 	=1796	+Evaluator());%0A%09%09BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew(%22FUNCTION%22, new Function	=214
//END OF FILE

//SESSION END

//SESSION START
96,Wed Dec 06 15:03:02 EST 2023,0
//START OF FILE: index/FunctionEvaluator.java
=410	-2	+T	=1	-1	+il	=6	-1	+He	=1	-2	+d	=92
//END OF FILE

//SESSION END

//SESSION START
101,Wed Dec 06 17:39:16 EST 2023,2676
//START OF FILE: index/FuncallEvaluator.java
=878	-323	=5
//END OF FILE
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
=649	-61	=195	-255	=723
//END OF FILE
//START OF FILE: index/CurryEvaluator.java
package index;

import java.util.ArrayList;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.evaluator.function.Lambda;
import main.lisp.evaluator.function.LambdaFactory;
import main.lisp.parser.terms.ExpressionFactory;
import main.lisp.parser.terms.IdentifierAtom;
import main.lisp.parser.terms.NilAtom;
import main.lisp.parser.terms.SExpression;
import net.sf.saxon.functions.SuperId.Id;

public class CurryEvaluator implements Evaluator{

    @Override
    public SExpression eval(SExpression expr, Environment environment) {
        expr = expr.getTail();
        return evalHelper(expr, environment);
    }

    public static SExpression evalHelper(SExpression expr, Environment environment) {
        Lambda flambda = (Lambda) expr.getHead();
        IdentifierAtom identifierAtoms[] = flambda.getArgumentNames();
        SExpression expressions[] = getExpressions(expr.getTail());
        IdentifierAtom curryLambdaArgs[] = new IdentifierAtom[identifierAtoms.length - expressions.length];
        for(int i = expressions.length; i < identifierAtoms.length; i++) {
            curryLambdaArgs[i - expressions.length] = identifierAtoms[i];
        }

        SExpression curryFlambda = ExpressionFactory.newInstance(new IdentifierAtom("QUOTE"), flambda);
        SExpression first = ExpressionFactory.newInstance(new IdentifierAtom("FUNCALL"), curryFlambda);
        SExpression second = quoteMakeList(expressions);
        SExpression third = makeList(curryLambdaArgs);
        SExpression curryLambdaBody = ExpressionFactory.newInstance(first, second);
        curryLambdaBody = ExpressionFactory.newInstance(curryLambdaBody, third);
        return LambdaFactory.newInstance(curryLambdaArgs, curryLambdaBody);
    }

    private static SExpression[] getExpressions(SExpression expr) {
        ArrayList<SExpression> expressions = new ArrayList<>();
        while(!(expr instanceof NilAtom)) {
            expressions.add(expr.getHead());
            expr = expr.getTail();
        }
        SExpression[] idArray = new SExpression[expressions.size()];
        for(SExpression id : expressions) {
            idArray[expressions.indexOf(id)] = id;
        }
        return idArray;
    }

    private static SExpression quoteMakeList(SExpression expression[]){
        SExpression retVal = ExpressionFactory.newInstance(new IdentifierAtom("QUOTE"), expression[0]);
        if(expression.length == 1){
            return retVal;
        }else{
            for(int i = 1; i < expression.length; i++){
                SExpression tempExpression = ExpressionFactory.newInstance(new IdentifierAtom("QUOTE"), expression[i]);
                retVal = ExpressionFactory.newInstance(retVal, tempExpression);
            }
            return retVal;
        }
    }

    private static SExpression makeList(IdentifierAtom ids[]){
        SExpression retVal = ids[0];
        if(ids.length == 1){
            return retVal;
        }else{
            for(int i = 1; i < ids.length; i++){
                SExpression tempExpression = ids[i];
                retVal = ExpressionFactory.newInstance(retVal, tempExpression);
            }
            return retVal;
        }
    }
}

//END OF FILE
//START OF FILE: index/OperationRegistererImpl.java
=2020	-1	+%09BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew(%22CURRY%22, new CurryEvaluator());	=2	+%7D	=1	+%09	=191	-1	=3
//END OF FILE
//START OF FILE: index/index.java
=624	-1	=2
//END OF FILE

//SESSION END

//SESSION START
102,Wed Dec 06 17:42:35 EST 2023,56
//START OF FILE: index/CurryEvaluator.java
=1465	+, environment	=846	+, Environment environment	=358	+.eval(environment)	=553
//END OF FILE

//SESSION END

//SESSION START
103,Wed Dec 06 17:45:18 EST 2023,18
//START OF FILE: index/CurryEvaluator.java
=794	+.eval(environment)	=2484
//END OF FILE

//SESSION END

//SESSION START
107,Wed Dec 06 17:56:38 EST 2023,18
//START OF FILE: index/CurryEvaluator.java
=2471	+.eval(environment)	=825
//END OF FILE

//SESSION END

//SESSION START
110,Wed Dec 06 18:40:20 EST 2023,114
//START OF FILE: index/CurryEvaluator.java
=1220	-1	=20	-2	+ze	=1	+o = new Identifie	=1	-1	+Atom(%22	=1	-6	+UNCALL%22);%0A        SExpression first	=79	+ //	=290	+zero, 	=5	-8	=59	+first, second);%0A        	=15	+ = ExpressionFactory.newInstance(second	=1605
//END OF FILE

//SESSION END

//SESSION START
111,Wed Dec 06 18:43:21 EST 2023,10
//START OF FILE: index/CurryEvaluator.java
=1675	-70	=85	+);%0A        curryLambdaBody = ExpressionFactory.newInstance(zero, curryLambdaBody	=1598
//END OF FILE

//SESSION END

//SESSION START
112,Wed Dec 06 18:45:23 EST 2023,9
//START OF FILE: index/CurryEvaluator.java
=1747	-2	=1	+urryLambdaB	=1	-1	=1	+y	=1685
//END OF FILE

//SESSION END

//SESSION START
113,Wed Dec 06 20:03:35 EST 2023,189
//START OF FILE: index/CurryEvaluator.java
=52	+org.apache.commons.collections.functors.ExceptionFactory;%0A%0Aimport 	=1188	+curryLambdaBody = ExpressionFactory.newInstance(new IdentifierAtom(%22QUOTE%22), flambda);%0A        curryLambdaBody = quoteMakeList(curryLambdaBody, expressions, environment);%0A        curryLambdaBody = makeList(curryLambdaBody, curryLambdaArgs);%0A        curryLambdaBody = ExpressionFactory.newInstance(new IdentifierAtom(%22FUNCALL%22), curryLambdaBody);%0A%0A        // SExpression 	=45	+ //	=97	+ //	=108	+// 	=35	+flambda, 	=35	+// 	=29	+second, 	=26	+// // 	=67	-5	+thir	=12	+// // 	=81	+// SExpression 	=54	-3	+thi	=1	-5	=1	-5	=614	-3	+cu	=1	-14	=1	-2	+yLa	=1	-9	+bdaB	=1	-15	+dy,	=13	-1	=1	-8	=9	-47	+%5B%5D	=2	-20	+E	=10	-8	=1	-3	+env	=1	-5	=1	-4	=2	-2	+m	=2	-1	=1	-6	=11	-46	=12	-1	+0	=31	-1	=12	-3	=134	-4	+cur	=1	-3	+yLambd	=1	-1	+Body	=33	+cu	=1	-3	+ryLambd	=1	-1	+Body	=19	-2	=8	-2	=2	-4	=15	+cu	=1	-3	+ryLambd	=1	-1	+Body	=1	-10	=48	-31	=18	-18	+,	=1	-4	+I	=1	-3	=2	-1	=1	-22	+ifi	=1	-2	=1	-4	+A	=1	-12	+om	=1	-3	+id	=1	-1	+%5B%5D)	=2	-4	=20	-1	+0	=24	-4	=49	-2	=12	-2	=72	-4	=2	-1	=8	-3	=14	-10	=9
//END OF FILE

//SESSION END

//SESSION START
114,Wed Dec 06 20:04:08 EST 2023,0
//START OF FILE: index/CurryEvaluator.java
=1419	+ExpressionFactory.newInstance(new IdentifierAtom(%22FUNCALL%22), curryLambdaBody);%0A        curryLambdaBody = 	=125	-105	=1987
//END OF FILE

//SESSION END

//SESSION START
115,Wed Dec 06 20:58:15 EST 2023,-284
//START OF FILE: index/FuncallEvaluator.java
=214	-88	=581
//END OF FILE
//START OF FILE: index/CurryEvaluator.java
=1286	+%0A	=390	-2	+cu	=1	-17	=1	-11	+y	=1	-25	+ambdaB	=1	-7	+dy	=3	-4	+mak	=1	-2	+L	=1	-15	=2	-4	=1	-13	+cu	=1	-17	+ryL	=5	+Args	=10	-3	=4	-81	=5	-2	+L	=5	-23	+B	=1	-7	=1	+y	=17	-2	+curryL	=5	+Body	=53	-10	=1	-20	=1	-27	+p	=1	-23	=33	+new Identi	=2	+e	=1	-1	+A	=1	+om(%22QUOTE%22)	=2	-4	+flamb	=1	+a	=10	-3	=52	+tempp, 	=15	-7	=13	-12	=49	-1	+new Identifi	=2	+At	=1	+m(%22FUNCALL%22)	=2	-3	+cur	=1	+yLamb	=1	+aBody	=1064	+cu	=1	-3	+ryLambd	=1	-1	+Body	=131	+cu	=1	-3	+ryLambd	=1	-1	+Body	=33	-8	=14	+, curryLambdaBody	=28	+cu	=1	-3	+ryLambd	=1	-1	+Body	=10
//END OF FILE

//SESSION END

//SESSION START
116,Wed Dec 06 21:21:18 EST 2023,1242
//START OF FILE: index/LetEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.IdentifierAtom;
import main.lisp.parser.terms.NilAtom;
import main.lisp.parser.terms.SExpression;

public class LetEvaluator implements Evaluator{

    @Override
    public SExpression eval(SExpression expr, Environment environment) {
        expr = expr.getTail();
        return evalHelper(expr, environment);
    }
    
    public static SExpression evalHelper(SExpression expr, Environment environment) {
        Environment childEnvironment = environment.newChild();
        SExpression headExpr = expr.getHead();
        while(!(headExpr instanceof NilAtom)){
            IdentifierAtom temp = (IdentifierAtom)(headExpr.getHead().getHead());
            SExpression temp2 = headExpr.getHead().getTail().getHead().eval(environment);
            childEnvironment.assign(temp, temp2);
            headExpr = headExpr.getTail();
        }
        SExpression tailExpr = expr.getTail();
        while(!(tailExpr.getTail() instanceof NilAtom)){
            tailExpr.getHead().eval(childEnvironment);
            tailExpr = tailExpr.getTail();
        }
        return tailExpr.getHead().eval(childEnvironment);
    }
}

//END OF FILE
//START OF FILE: index/OperationRegistererImpl.java
=2116	+%09BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew(%22LET%22, new LetEvaluator());%0A%09	=197
//END OF FILE
//START OF FILE: index/ClassRegistryImpl.java
=2849	-17	=1	-6	=2	-6	=1	-6	=1	-3	=1	-2	=1	-56	=12	-3	+.class	=932
//END OF FILE

//SESSION END

//SESSION START
117,Wed Dec 06 21:22:21 EST 2023,131
//START OF FILE: index/FuncallEvaluator.java
=23	+java.beans.Expression;%0A%0Aimport 	=159	+;%0Aimport main.lisp.parser.terms.ExpressionFactory	=349	+%0A        ExpressionFactory.newInstance(expr, expr);	=264
//END OF FILE

//SESSION END

//SESSION START
118,Wed Dec 06 21:39:59 EST 2023,-556
//START OF FILE: index/CurryEvaluator.java
=52	-66	=341	-42	=1149	-448	=1342
//END OF FILE

//SESSION END

//START OF FILE: index/OperationRegistererImpl.java
package index;

import main.lisp.evaluator.OperationRegisterer;
import valgrindpp.codegen.Function;
import main.lisp.evaluator.BasicOperationRegisterer;
import main.lisp.evaluator.BuiltinOperationManagerSingleton;

public class OperationRegistererImpl extends BasicOperationRegisterer implements OperationRegisterer{
	
	public static void registerBasic() {
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("QUOTE", new QuoteEvaluator());
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("LIST", new ListEvaluator());
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("LOAD", new LoadEvaluator());
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("EVAL", new EvalEvaluator());
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("COND", new CondEvaluator());
	}
	
	public static void registerArithmetic() {
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew(">", new GreaterEvaluator());
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("<", new LesserEvaluator());
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew(">=", new GreaterEqualEvaluator());
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("<=", new LesserEqualEvaluator());
	}
	
	public static void registerLogic() {
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("AND", new AndEvaluator());
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("OR", new OrEvaluator());
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("NOT", new NotEvaluator());
	}
	
	public static void registerAdvance() {
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("SETQ", new SetqEvaluator());
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("LAMBDA", new LambdaEvaluator());
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("FUNCALL", new FuncallEvaluator());
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("FUNCTION", new FunctionEvaluator());
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("CURRY", new CurryEvaluator());
		BuiltinOperationManagerSingleton.get().registerEvaluatorIfNew("LET", new LetEvaluator());
	}
	
	@Override
	public void registerOperations() {
		registerAll();
	}
	
	public static void registerAll() {
		registerBasic();
		registerArithmetic();
		registerLogic();
		registerAdvance();
	}
}

//END OF FILE
//START OF FILE: index/CondEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.NilAtom;
import main.lisp.parser.terms.SExpression;

public class CondEvaluator implements Evaluator{

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		expr = expr.getTail();
		return evalHelper(expr, environment);
//		return expr;
	}
	
	public static SExpression evalHelper(SExpression expr, Environment environment) {
		if(expr.isNIL()) {
			return new NilAtom();
		}
		if(!expr.getHead().getHead().eval(environment).isNIL()) {
			if(expr.getHead().getTail() instanceof NilAtom) {
				return expr.getHead().getHead().eval(environment);
			}
			if(expr.getHead().getTail().isAtom()) {
				return expr.getHead().getTail();
			}else {
				return expr.getHead().getTail().getHead().eval(environment);
			}
		}else {
			return evalHelper(expr.getTail(), environment);
		}
	}
}

//END OF FILE
//START OF FILE: index/ClassRegistryImpl.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;	
import main.lisp.evaluator.OperationRegisterer;
import main.lisp.parser.terms.IdentifierAtom;
import main.lisp.parser.terms.SExpression;
import gradingTools.comp524f23.assignment6.ClassRegistryA6;

public class ClassRegistryImpl implements ClassRegistryA6 {

	@Override
	public Class<? extends Evaluator> getAndEvaluator() {
		// TODO Auto-generated method stub
		return AndEvaluator.class;
	}

	@Override
	public Class<? extends Evaluator> getCondEvaluator() {
		// TODO Auto-generated method stub
		return CondEvaluator.class;
	}

	@Override
	public Class<? extends OperationRegisterer> getCustomOperationRegisterer() {
		// TODO Auto-generated method stub
		return OperationRegistererImpl.class;
	}

	@Override
	public Class<? extends Evaluator> getEvalEvaluator() {
		// TODO Auto-generated method stub
		return EvalEvaluator.class;
	}

	@Override
	public Class<? extends Evaluator> getGTEEvaluator() {
		// TODO Auto-generated method stub
		return GreaterEqualEvaluator.class;
	}

	@Override
	public Class<? extends Evaluator> getGTEvaluator() {
		// TODO Auto-generated method stub
		return GreaterEvaluator.class;
	}

	@Override
	public Class<? extends Evaluator> getLTEEvaluator() {
		// TODO Auto-generated method stub
		return LesserEqualEvaluator.class;
	}

	@Override
	public Class<? extends Evaluator> getLTEvaluator() {
		// TODO Auto-generated method stub
		return LesserEvaluator.class;
	}

	@Override
	public Class<? extends Evaluator> getListEvaluator() {
		// TODO Auto-generated method stub
		return ListEvaluator.class;
	}

	@Override
	public Class<? extends Evaluator> getLoadEvaluator() {
		// TODO Auto-generated method stub
		return LoadEvaluator.class;
	}

	@Override
	public Class<?> getMain() {
		// TODO Auto-generated method stub
		return index.class;
	}

	@Override
	public Class<? extends Evaluator> getNotEvaluator() {
		// TODO Auto-generated method stub
		return NotEvaluator.class;
	}

	@Override
	public Class<? extends Evaluator> getOrEvaluator() {
		// TODO Auto-generated method stub
		return OrEvaluator.class;
	}

	@Override
	public Class<? extends Evaluator> getQuoteEvaluator() {
		// TODO Auto-generated method stub
		return QuoteEvaluator.class;
	}

	@Override
	public Class<? extends SExpression> getStringFormattingSExpression() {
		// TODO Auto-generated method stub
		return BasicExpressionImpl.class;
	}

	@Override
	public Class<? extends SExpression> getFunctionCallingSExpression() {
		// TODO Auto-generated method stub
		throw new UnsupportedOperationException("Unimplemented method 'getFunctionCallingSExpression'");
	}

	@Override
	public Class<? extends Evaluator> getFunctionEvaluator() {
		return FuncallEvaluator.class;
	}

	@Override
	public Class<? extends Evaluator> getLetEvaluator() {
		return LetEvaluator.class;
	}

	@Override
	public Class<? extends Evaluator> getBasicFuncallEvaluator() {
		return FuncallEvaluator.class;
	}

	@Override
	public Class<? extends IdentifierAtom> getIdentifierAtomWithLookup() {
		return IdentifierAtomImpl.class;
	}

	@Override
	public Class<? extends SExpression> getLambdaCallingSExpression() {
		return null;
	}

	@Override
	public Class<? extends Evaluator> getLambdaEvaluator() {
		return LambdaEvaluator.class;
	}

	@Override
	public Class<? extends Environment> getNestedLexicalEnvironment() {
		// TODO Auto-generated method stub
		return EnvironmentImpl.class;
	}

	@Override
	public Class<? extends Evaluator> getSetqEvaluator() {
		return SetqEvaluator.class;
	}

	@Override
	public Class<? extends OperationRegisterer> getStatefulOperationRegisterer() {
		// TODO Auto-generated method stub
		throw new UnsupportedOperationException("Unimplemented method 'getStatefulOperationRegisterer'");
	}

}

//END OF FILE
//START OF FILE: index/BasicExpressionEvaluatorImpl.java
package index;

import main.lisp.evaluator.BasicExpressionEvaluator;
import main.lisp.evaluator.BuiltinOperationManagerSingleton;
import main.lisp.evaluator.Environment;
import main.lisp.evaluator.function.BasicLambda;
import main.lisp.evaluator.function.Function;
import main.lisp.evaluator.function.Lambda;
import main.lisp.parser.terms.IdentifierAtom;
import main.lisp.parser.terms.SExpression;

public class BasicExpressionEvaluatorImpl extends BasicExpressionEvaluator{

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		if(!(expr.getHead() instanceof IdentifierAtom)){
			SExpression temp = expr.getHead();
			Lambda lambda;
			if(!(temp.getClass().equals(BasicLambda.class))) {
				lambda = (Lambda)temp.eval(environment);
			}else {
				lambda = (Lambda)temp;
			}
			return lambdaHelper(lambda, expr, environment);
		}else{
			return BuiltinOperationManagerSingleton.get().getEvaluator(expr.getHead().toString()).eval(expr, environment);
		}
	}

	public static SExpression lambdaHelper(Lambda lambda, SExpression expr, Environment environment){
		Environment childEnvironment = environment.newChild();
		IdentifierAtom[] ids = lambda.getArgumentNames();
		for (IdentifierAtom id : ids){
			childEnvironment.assign(id, expr.getTail().getHead().eval(environment));
			expr = expr.getTail();
		}
		return lambda.eval(childEnvironment);
	}

	public static SExpression functionHelper(Function function, SExpression expr, Environment environment){
		return lambdaHelper(function.getLambda(), expr, function.getEnvironment());
	}
}

//END OF FILE
//START OF FILE: index/SetqEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.IdentifierAtom;
import main.lisp.parser.terms.SExpression;

public class SetqEvaluator implements Evaluator{

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		expr = expr.getTail();
		return evalHelper(expr, environment);
	}
	
	public static SExpression evalHelper(SExpression expr, Environment environment) {
        SExpression e2 = expr.getTail().getHead();
        SExpression e2Eval = e2.eval(environment);
        environment.assign((IdentifierAtom)expr.getHead(), e2Eval);
        return e2Eval;
	}
}

//END OF FILE
//START OF FILE: index/index.java
package index;

import main.Main;
import main.lisp.parser.terms.ExpressionFactory;
import main.lisp.parser.terms.IdentifierAtomFactory;
import main.lisp.evaluator.ExpressionEvaluatorFactory;
import main.lisp.evaluator.environment.EnvironmentFactory;

public class index {

	public static void main(String[] args) {
		ExpressionEvaluatorFactory.setClass(BasicExpressionEvaluatorImpl.class);
		IdentifierAtomFactory.setClass(IdentifierAtomImpl.class);
		EnvironmentFactory.setClass(EnvironmentImpl.class);
		OperationRegistererImpl.registerAll();
		ExpressionFactory.setClass(BasicExpressionImpl.class);
		Main.main(args);
	}
}

//END OF FILE
//START OF FILE: index/LetEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.IdentifierAtom;
import main.lisp.parser.terms.NilAtom;
import main.lisp.parser.terms.SExpression;

public class LetEvaluator implements Evaluator{

    @Override
    public SExpression eval(SExpression expr, Environment environment) {
        expr = expr.getTail();
        return evalHelper(expr, environment);
    }
    
    public static SExpression evalHelper(SExpression expr, Environment environment) {
        Environment childEnvironment = environment.newChild();
        SExpression headExpr = expr.getHead();
        while(!(headExpr instanceof NilAtom)){
            IdentifierAtom temp = (IdentifierAtom)(headExpr.getHead().getHead());
            SExpression temp2 = headExpr.getHead().getTail().getHead().eval(environment);
            childEnvironment.assign(temp, temp2);
            headExpr = headExpr.getTail();
        }
        SExpression tailExpr = expr.getTail();
        while(!(tailExpr.getTail() instanceof NilAtom)){
            tailExpr.getHead().eval(childEnvironment);
            tailExpr = tailExpr.getTail();
        }
        return tailExpr.getHead().eval(childEnvironment);
    }
}

//END OF FILE
//START OF FILE: index/LoadEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.NilAtom;
import main.lisp.parser.terms.TAtom;
import main.lisp.parser.terms.SExpression;
import main.lisp.parser.terms.StringAtom;
import main.lisp.interpreter.InterpreterModel;
import main.lisp.interpreter.InterpreterModelSingleton;
import main.lisp.parser.terms.TAtomicExpressionFactory;
import main.lisp.parser.terms.NilAtomicExpressionFactory;


import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

public class LoadEvaluator implements Evaluator {

    @Override
    public SExpression eval(SExpression expr, Environment environment) {
        // Ensure the argument is a string
        if(expr.getTail().getHead() instanceof NilAtom) {
        	return NilAtomicExpressionFactory.newInstance();
        }

        String fileName = ((StringAtom)(expr.getTail().getHead())).getValue();
//        fileName = fileName.substring(fileName.lastIndexOf("/") + 1, fileName.length() - 1);
//        System.out.println("Filename: " + fileName);
        try {
//        	Charset charset = Charset.forName("ISO-8859-1");
        	List<String> lines = Files.readAllLines(Path.of(fileName));


            // Get the singleton instance of the interpreter model
            InterpreterModel interpreterModel = InterpreterModelSingleton.get();

            for (String line : lines) {
                interpreterModel.newInput(line);
            }

            return TAtomicExpressionFactory.newInstance();
        } catch (IOException e) {
        	System.out.println(e);
            return NilAtomicExpressionFactory.newInstance();
        }
    }
}

//END OF FILE
//START OF FILE: index/LesserEqualEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.DecimalAtom;
import main.lisp.parser.terms.IntegerAtom;
import main.lisp.parser.terms.NilAtom;
import main.lisp.parser.terms.SExpression;
import main.lisp.parser.terms.TAtom;
import main.lisp.parser.terms.TAtomicExpressionFactory;
import main.lisp.parser.terms.NilAtomicExpressionFactory;

public class LesserEqualEvaluator extends ArithmeticEvaluatorHelper implements Evaluator {

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		return super.getDifference(expr, environment, "LesserEqual");
	}
}

//END OF FILE
//START OF FILE: index/AndEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.SExpression;
import main.lisp.parser.terms.NilAtom;

public class AndEvaluator implements Evaluator {

    @Override
    public SExpression eval(SExpression expr, Environment environment) {
        expr = expr.getTail();
        return evalHelper(expr, environment, null);
    }

    public static SExpression evalHelper(SExpression expr, Environment environment, SExpression lastEvaluated) {
        if (expr instanceof NilAtom) {
            return lastEvaluated;
        }
        SExpression current = expr.getHead().eval(environment);
        if (current.isNIL()) {
            return current;
        } else {
            return evalHelper(expr.getTail(), environment, current);
        }
    }
}

//END OF FILE
//START OF FILE: index/ListEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.SExpression;
import main.lisp.parser.terms.ExpressionFactory;

public class ListEvaluator implements Evaluator{

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		expr = expr.getTail();
		return evalHelper(expr, environment);
//		return expr;
	}
	
	public static SExpression evalHelper(SExpression expr, Environment environment) {
		if(expr.isAtom()) {
			return expr.eval(environment);
		}
		return ExpressionFactory.newInstance(expr.getHead().eval(environment), evalHelper(expr.getTail(), environment));
		
	}

}

//END OF FILE
//START OF FILE: index/FuncallEvaluator.java
package index;

import java.beans.Expression;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.evaluator.function.Function;
import main.lisp.evaluator.function.Lambda;
import main.lisp.parser.terms.ExpressionFactory;
import main.lisp.parser.terms.SExpression;


public class FuncallEvaluator implements Evaluator{

    @Override
    public SExpression eval(SExpression expr, Environment environment) {
        expr = expr.getTail();
		return evalHelper(expr, environment);
    }
    public static SExpression evalHelper(SExpression expr, Environment environment) {
        ExpressionFactory.newInstance(expr, expr);
        SExpression body = expr.getHead().eval(environment);
        return body instanceof Lambda ? BasicExpressionEvaluatorImpl.lambdaHelper((Lambda)body, expr, environment) : BasicExpressionEvaluatorImpl.functionHelper((Function)body, expr, environment);
	}
}

//END OF FILE
//START OF FILE: index/OrEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.SExpression;

public class OrEvaluator implements Evaluator {

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		expr = expr.getTail();
		return evalHelper(expr, environment);
	}

	public static SExpression evalHelper(SExpression expr, Environment environment) {
		if(expr.isAtom()) {
			if(expr.isNIL()) {
				return expr;
			}else {
				return expr;
			}
		}
		if(expr.getHead().eval(environment).isNIL()) {
			return evalHelper(expr.getTail(), environment);
		}else {
			return expr.getHead().eval(environment);
		}		
	}

}
//END OF FILE
//START OF FILE: index/GreaterEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.DecimalAtom;
import main.lisp.parser.terms.IntegerAtom;
import main.lisp.parser.terms.NilAtom;
import main.lisp.parser.terms.SExpression;
import main.lisp.parser.terms.TAtom;

public class GreaterEvaluator extends ArithmeticEvaluatorHelper implements Evaluator{

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		return super.getDifference(expr, environment, "greater");
	}

}

//END OF FILE
//START OF FILE: index/CurryEvaluator.java
package index;

import java.util.ArrayList;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.evaluator.function.Lambda;
import main.lisp.evaluator.function.LambdaFactory;
import main.lisp.parser.terms.ExpressionFactory;
import main.lisp.parser.terms.IdentifierAtom;
import main.lisp.parser.terms.NilAtom;
import main.lisp.parser.terms.SExpression;

public class CurryEvaluator implements Evaluator{

    @Override
    public SExpression eval(SExpression expr, Environment environment) {
        expr = expr.getTail();
        return evalHelper(expr, environment);
    }

    public static SExpression evalHelper(SExpression expr, Environment environment) {
        Lambda flambda = (Lambda) expr.getHead().eval(environment);
        IdentifierAtom identifierAtoms[] = flambda.getArgumentNames();
        SExpression expressions[] = getExpressions(expr.getTail());
        IdentifierAtom curryLambdaArgs[] = new IdentifierAtom[identifierAtoms.length - expressions.length];
        for(int i = expressions.length; i < identifierAtoms.length; i++) {
            curryLambdaArgs[i - expressions.length] = identifierAtoms[i];
        }

        SExpression curryLambdaBody = ExpressionFactory.newInstance(new IdentifierAtom("QUOTE"), flambda);
        curryLambdaBody = ExpressionFactory.newInstance(new IdentifierAtom("FUNCALL"), curryLambdaBody);
        curryLambdaBody = quoteMakeList(curryLambdaBody, expressions, environment);
        curryLambdaBody = makeList(curryLambdaBody, curryLambdaArgs);
        return LambdaFactory.newInstance(curryLambdaArgs, curryLambdaBody);
    }

    private static SExpression[] getExpressions(SExpression expr) {
        ArrayList<SExpression> expressions = new ArrayList<>();
        while(!(expr instanceof NilAtom)) {
            expressions.add(expr.getHead());
            expr = expr.getTail();
        }
        SExpression[] idArray = new SExpression[expressions.size()];
        for(SExpression id : expressions) {
            idArray[expressions.indexOf(id)] = id;
        }
        return idArray;
    }

    private static SExpression quoteMakeList(SExpression curryLambdaBody, SExpression expression[], Environment environment){
        for(int i = 0; i < expression.length; i++){
            SExpression tempExpression = ExpressionFactory.newInstance(new IdentifierAtom("QUOTE"), expression[i].eval(environment));
            curryLambdaBody = ExpressionFactory.newInstance(curryLambdaBody, tempExpression);
        }
        return curryLambdaBody;
    }

    private static SExpression makeList(SExpression curryLambdaBody, IdentifierAtom ids[]){
        for(int i = 0; i < ids.length; i++){
            SExpression tempExpression = ids[i];
            curryLambdaBody = ExpressionFactory.newInstance(tempExpression, curryLambdaBody);
        }
        return curryLambdaBody;
    }
}

//END OF FILE
//START OF FILE: index/GreaterEqualEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.DecimalAtom;
import main.lisp.parser.terms.IntegerAtom;
import main.lisp.parser.terms.NilAtom;
import main.lisp.parser.terms.SExpression;
import main.lisp.parser.terms.TAtom;

public class GreaterEqualEvaluator extends ArithmeticEvaluatorHelper implements Evaluator {

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		return super.getDifference(expr, environment, "GreaterEqual");
	}

}

//END OF FILE
//START OF FILE: index/ArithmeticEvaluatorHelper.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.parser.terms.DecimalAtom;
import main.lisp.parser.terms.IntegerAtom;
import main.lisp.parser.terms.NilAtomicExpressionFactory;
import main.lisp.parser.terms.SExpression;
import main.lisp.parser.terms.TAtomicExpressionFactory;

public class ArithmeticEvaluatorHelper {
	
	public static SExpression getDifference(SExpression expr, Environment environment, String comparator) {
		expr = expr.getTail();
		
		SExpression firstEvaled = expr.getHead().eval(environment);
		SExpression secondEvaled = expr.getTail().getHead().eval(environment);
		
		IntegerAtom firstInt = null;
		IntegerAtom secondInt = null;
		DecimalAtom firstDec = null;
		DecimalAtom secondDec = null;
		
		if (firstEvaled instanceof IntegerAtom) {
			firstInt = (IntegerAtom)firstEvaled;
			secondInt = (IntegerAtom)secondEvaled;
		}
		if (firstEvaled instanceof DecimalAtom) {
			firstDec = (DecimalAtom)firstEvaled;
			secondDec = (DecimalAtom)secondEvaled;
		}
		double difference = firstInt.getValue() - secondInt.getValue();
		if(comparator.equals("greater")) {
			if(difference > 0) {
				return TAtomicExpressionFactory.newInstance();
			}else {
				return NilAtomicExpressionFactory.newInstance();
			}
		}else if(comparator.equals("lesser")) {
			if(difference < 0) {
				return TAtomicExpressionFactory.newInstance();
			}else {
				return NilAtomicExpressionFactory.newInstance();
			}
		}else if(comparator.equals("GreaterEqual")){
			if(difference >= 0) {
				return TAtomicExpressionFactory.newInstance();
			}else {
				return NilAtomicExpressionFactory.newInstance();
			}
		}else {
			if(difference <= 0) {
				return TAtomicExpressionFactory.newInstance();
			}else {
				return NilAtomicExpressionFactory.newInstance();
			}
		}
	}
}

//END OF FILE
//START OF FILE: index/BasicExpressionImpl.java
package index;

import main.lisp.parser.terms.AbstractSExpression;
import main.lisp.parser.terms.Atom;
import main.lisp.parser.terms.BasicExpression;
import main.lisp.parser.terms.SExpression;

public class BasicExpressionImpl extends BasicExpression implements SExpression{
	
	public BasicExpressionImpl(SExpression head, SExpression tail) {
		super(head, tail);
	}

	@Override
	public boolean isList() {
		if((this.getTail() instanceof Atom)) {
			return this.getTail().isNIL();
		}else {
			return this.getTail().isList();
		}
	}

	@Override
	public String toStringAsSExpressionDeep() {
		if(this.isAtom()) {
			return "(" + this.toString() + ")";
		}
		return "(" + this.getHead().toStringAsSExpressionDeep() + " " + "." + " " +
				this.getTail().toStringAsSExpressionDeep() + ")";
	}

	@Override
	public String toStringAsSExpression() {
		return "(" + this.getHead().toString() + " " + "." + " " +
				this.getTail().toString() + ")";
	}

	@Override
	public String toStringAsList() {
		return "("+((AbstractSExpression)this).toStringAsListHelperPublic()+")";
	}

	@Override
	public String toString() {
		return this.isList()? this.toStringAsList() : this.toStringAsSExpression();
	}

	@Override
	public String toStringAsListHelperPublic() {
		if(this.getTail().isNIL()) {
			return this.getHead().toString();
		}else {
			return this.getHead().toString() + " " + ((AbstractSExpression)this.getTail()).toStringAsListHelperPublic();	
		}
	}

}

//END OF FILE
//START OF FILE: index/FunctionEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.evaluator.function.FunctionFactory;
import main.lisp.evaluator.function.Lambda;
import main.lisp.parser.terms.SExpression;

public class FunctionEvaluator implements Evaluator{

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
        Lambda lambda = (Lambda)expr.getTail().getHead().eval(environment);
        return FunctionFactory.newInstance(lambda, environment);
	}
}

//END OF FILE
//START OF FILE: index/NotEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.NilAtom;
import main.lisp.parser.terms.SExpression;
import main.lisp.parser.terms.TAtom;
import main.lisp.parser.terms.TAtomicExpressionFactory;
import main.lisp.parser.terms.NilAtomicExpressionFactory;

public class NotEvaluator implements Evaluator {

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		expr = expr.getTail().getHead();
		if(expr.isNIL()) {
			return TAtomicExpressionFactory.newInstance();
		}else {
			return NilAtomicExpressionFactory.newInstance();
		}
	}

}

//END OF FILE
//START OF FILE: index/EvalEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.ExpressionFactory;
import main.lisp.parser.terms.IdentifierAtom;
import main.lisp.parser.terms.SExpression;
import main.lisp.evaluator.BuiltinOperationManagerSingleton;

public class EvalEvaluator implements Evaluator{

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		return expr.getTail().getHead().eval(environment).eval(environment);
	}
}

//END OF FILE
//START OF FILE: index/LambdaEvaluator.java
package index;

import java.util.ArrayList;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.IdentifierAtom;
import main.lisp.parser.terms.NilAtom;
import main.lisp.evaluator.function.LambdaFactory;
import main.lisp.parser.terms.SExpression;

public class LambdaEvaluator implements Evaluator{

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
        expr = expr.getTail();
		return evalHelper(expr, environment);
	}
	
	public static SExpression evalHelper(SExpression expr, Environment environment) {
		SExpression body = expr.getTail();
		IdentifierAtom ids[] = {};
		if(expr.getHead() instanceof NilAtom) {
			return LambdaFactory.newInstance(ids, body);
		}
        ids = extractIdentifiers(expr.getHead());
        return LambdaFactory.newInstance(ids, body);
	}

    private static IdentifierAtom[] extractIdentifiers(SExpression expr) {
        ArrayList<IdentifierAtom> ids = new ArrayList<>();
        while(!(expr instanceof NilAtom)) {
            ids.add((IdentifierAtom) expr.getHead());
            expr = expr.getTail();
        }
        IdentifierAtom[] idArray = new IdentifierAtom[ids.size()];
        for(IdentifierAtom id : ids) {
            idArray[ids.indexOf(id)] = id;
        }
        return idArray;
    }
}
//END OF FILE
//START OF FILE: index/LesserEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.DecimalAtom;
import main.lisp.parser.terms.IntegerAtom;
import main.lisp.parser.terms.NilAtom;
import main.lisp.parser.terms.SExpression;
import main.lisp.parser.terms.TAtom;
import main.lisp.parser.terms.TAtomicExpressionFactory;
import main.lisp.parser.terms.NilAtomicExpressionFactory;


public class LesserEvaluator extends ArithmeticEvaluatorHelper implements Evaluator{

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		return super.getDifference(expr, environment, "lesser");
	}

}

//END OF FILE
//START OF FILE: index/IdentifierAtomImpl.java
package index;

import java.util.Optional;

import main.lisp.scanner.tokens.Token;
import main.lisp.evaluator.Environment;
import main.lisp.parser.terms.IdentifierAtom;
import main.lisp.parser.terms.SExpression;

public class IdentifierAtomImpl extends IdentifierAtom{

    public IdentifierAtomImpl(String string) {
        super(string);
    }
    
    public IdentifierAtomImpl(Token token) {
        super(token);
     }

    @Override
    public SExpression eval(Environment var1){
        Optional<SExpression> retVal = var1.lookup(this);
        if(retVal.isPresent()) {
            return retVal.get();
        }
        return this;
    }
}

//END OF FILE
//START OF FILE: index/RunF23A5Tests.java
package index;

import grader.basics.execution.BasicProjectExecution;
import gradingTools.comp524f23.assignment6.F23Assignment6Suite;
import trace.grader.basics.GraderBasicsTraceUtility;

public class RunF23A5Tests {
	public static void main(final String[] args) {
		
		final int maxPrintedTraces = 600;
		final int maxTraces = 2000;
		final int processTimeOut = 5;
		
		// if you set this to false, grader steps will not be traced
		GraderBasicsTraceUtility.setTracerShowInfo(true);	
		// if you set this to false, all grader steps will be traced,
		// not just the ones that failed		
		GraderBasicsTraceUtility.setBufferTracedMessages(true);
		// Change this number if a test trace gets longer than 600 and is clipped
		GraderBasicsTraceUtility.setMaxPrintedTraces(maxPrintedTraces);
		// Change this number if all traces together are longer than 2000
		GraderBasicsTraceUtility.setMaxTraces(maxTraces);
		// Change this number if your process times out prematurely
		BasicProjectExecution.setProcessTimeOut(processTimeOut);
		// You need to always call such a method
		F23Assignment6Suite.main(args);
	}
}

//END OF FILE
//START OF FILE: index/QuoteEvaluator.java
package index;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.Evaluator;
import main.lisp.parser.terms.SExpression;

public class QuoteEvaluator implements Evaluator{

	@Override
	public SExpression eval(SExpression expr, Environment environment) {
		if(expr.getTail().isAtom()) {
			return expr.getTail();
		}
		return expr.getTail().getHead();
	}
}

//END OF FILE
//START OF FILE: index/EnvironmentImpl.java
package index;

import java.util.Optional;

import main.lisp.evaluator.Environment;
import main.lisp.evaluator.environment.AbstractEnvironment;
import main.lisp.evaluator.function.Function;
import main.lisp.parser.terms.IdentifierAtom;
import main.lisp.parser.terms.SExpression;

public class EnvironmentImpl extends AbstractEnvironment{

	public EnvironmentImpl() {
		super();
	}

	public EnvironmentImpl(Environment parent) {
		super(parent);
	}

	@Override
	public void assign(IdentifierAtom arg0, SExpression arg1) {
		put(arg0, arg1);
	}

	@Override
	public void assignFun(IdentifierAtom arg0, Function arg1) {
		
	}

	@Override
	public Environment copy() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Optional<SExpression> lookup(IdentifierAtom arg0) {
		Optional<SExpression> retVal = get(arg0);
		return (retVal.isEmpty() && this.getParent() != null) ? this.getParent().lookup(arg0) : retVal;
	}

	@Override
	public Optional<Function> lookupFun(IdentifierAtom arg0) {
		// TODO Auto-generated method stub
		return Optional.empty();
	}

	@Override
	public Environment newChild() {
		return new EnvironmentImpl(this);
	}
	
}

//END OF FILE
